#lang racket

(random-seed 111) ; deterministic random
(define ns (make-base-namespace))

;;; AST

(struct «lit» (l d) #:transparent)
(struct «id» (l x) #:transparent)
(struct «quo» (l e) #:transparent)
(struct «lam» (l x e) #:transparent)
(struct «app» (l ae aes) #:transparent)
(struct «let» (l x e0 e1) #:transparent)
(struct «letrec» (l x e0 e1) #:transparent)
(struct «if» (l ae e0 e1) #:transparent)
(struct «set!» (l x ae) #:transparent)
(struct «begin» (l es) #:transparent)
(struct «car» (l x) #:transparent)
(struct «cdr» (l x) #:transparent)
(struct «set-car!» (l x ae) #:transparent)
(struct «set-cdr!» (l x ae) #:transparent)
(struct «cons» (l e0 e1) #:transparent)
(struct «vector-ref» (l x ae) #:transparent)
(struct «vector-set!» (l x ae1 ae2) #:transparent)
(struct «make-vector» (l ae1 ae2) #:transparent)

(define (compile . es)
  (define l -1)
  (define (tag!)
    (set! l (add1 l))
    l)
  (define (compile-seq es)
    (if (null? (cdr es))
        (compile* (car es))
        («begin» (tag!) (map compile* es))))
  (define (compile* e)
    (match e
      ((? symbol? d) («id» (tag!) (symbol->string d)))
      ((? boolean? d) («lit» (tag!) d))
      ((? number? d) («lit» (tag!) d))
      ((? string? d)(«lit» (tag!) d))
      ((? char? d) («lit» (tag!) d))
      (`(quote ,e) («quo» (tag!) e))
      (`(lambda ,x ,es ...) («lam» (tag!) (map compile* x) (compile-seq es)))
      (`(if ,ae ,e1 ,e2) («if» (tag!) (compile* ae) (compile* e1) (compile* e2)))
      (`(let ((,x ,e0)) ,es ...) («let» (tag!) (compile* x) (compile* e0) (compile-seq es)))
      (`(letrec ((,x ,e0)) ,es ...) («letrec» (tag!) (compile* x) (compile* e0) (compile-seq es)))
      (`(set! ,x ,ae) («set!» (tag!) (compile* x) (compile* ae)))
      (`(begin ,es ...) (compile-seq es))
      (`(car ,x) («car» (tag!) (compile* x)))
      (`(cdr ,x) («cdr» (tag!) (compile* x)))
      (`(cons ,ae1 ,ae2) («cons» (tag!) (compile* ae1) (compile* ae2)))
      (`(set-car! ,x ,ae) («set-car!» (tag!) (compile* x) (compile* ae)))
      (`(set-cdr! ,x ,ae) («set-cdr!» (tag!) (compile* x) (compile* ae)))
      (`(vector-ref ,x ,ae) («vector-ref» (tag!) (compile* x) (compile* ae)))
      (`(vector-set! ,x ,ae1 ,ae2) («vector-set!» (tag!) (compile* x) (compile* ae1) (compile* ae2)))
      (`(make-vector ,ae1 ,ae2) («make-vector» (tag!) (compile* ae1) (compile* ae2)))
      (`(,rator . ,rands) («app» (tag!) (compile* rator) (map compile* rands)))
      (_ (error "cannot handle expression" e))))
  (compile-seq es))


(define (children e)
  (match e
    ((«id» _ _) (set))
    ((«lit» _ _) (set))
    ((«lam» _ x e) (set-add (list->set x) e))
    ((«let» _ x e0 e1) (set x e0 e1))
    ((«letrec» _ x e0 e1) (set x e0 e1))
    ((«if» _ ae e1 e2) (set ae e1 e2))
    ((«car» _ x) (set x))
    ((«cdr» _ x) (set x))
    ((«set!» _ x ae) (set x ae))
    ((«set-car!» _ x ae) (set x ae))
    ((«set-cdr!» _ x ae) (set x ae))
    ((«cons» _ ae1 ae2) (set ae1 ae2))
    ((«make-vector» _ ae1 ae2) (set ae1 ae2))
    ((«vector-ref» _ x ae) (set x ae))
    ((«vector-set!» _ x ae1 ae2) (set x ae1 ae2))
    ((«quo» _ _) (set))
    ((«app» _ rator rands) (set-add (list->set rands) rator))
    ((«begin» _ es) (list->set es))
    (_ (error "cannot handle expression" e))))

(define (ast-seq->string es)
  (if (null? es)
      ""
      (if (null? (cdr es))
          (ast->string (car es))
          (string-append (ast->string (car es)) " " (ast-seq->string (cdr es))))))

(define (ast->string e)
  (match e
    ((«id» _ x) x)
    ((«lit» _ d) (~a d))
    ((«lam» _ x e) (format "(lambda (~a) ~a)" (ast-seq->string x) (ast->string e)))
    ((«let» _ x e0 e1) (format "(let ((~a ~a)) ~a)" (ast->string x) (ast->string e0) (ast->string e1)))
    ((«letrec» _ x e0 e1) (format "(letrec ((~a ~a)) ~a)" (ast->string x) (ast->string e0) (ast->string e1)))
    ((«if» _ e0 e1 e2) (format "(if ~a ~a ~a)" (ast->string e0) (ast->string e1) (ast->string e2)))
    ((«app» _ e es) (format "(~a ~a)" (ast->string e) (ast-seq->string es)))
    ((«begin» _ es) (format "(begin ~a)" (ast-seq->string es)))
    ((«set!» _ x e) (format "(set! ~a ~a)" (ast->string x) (ast->string e)))
    (_ (~a e))))

(define (make-parent ast)
  (define (parent-map ast)
    (define (traverse-ast S W)
      (if (set-empty? W)
          S
          (let* ((e (set-first W))
                 (E* (children e))
                 (S* (for/fold ((S S)) ((e* E*))
                       (hash-set S e* e)))
                 (W* (set-union (set-rest W) E*)))
            (traverse-ast S* W*))))
    (traverse-ast (hash) (set ast)))

  (let ((P (parent-map ast)))
    (lambda (e)
      (hash-ref P e #f))))

;;; DEBUG
(define (index v x)
  (let ((i (vector-member x v)))
    (if i
        i
        (let ((i (add1 (vector-ref v 0))))
          (vector-set! v 0 i)
          (vector-set! v i x)
          i))))
(define ctxis (make-vector 1000))
(define (ctx->ctxi ctx) (index ctxis ctx))

(define STACK 0)
(define (push-stack!) (set! STACK (add1 STACK)))
(define (pop-stack! d) (printf "\n~a value ~a\n" STACK d) (set! STACK (sub1 STACK)))

;;; ABSTRACT MACHINE

(struct binding (decl κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(binding ~a ~a)" (binding-decl v) (map ~a (binding-κ v)))))
(struct clo (lam κ) #:transparent
  #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(clo ~a ~a)" («lam»-l (clo-lam v)) (map ~a (clo-κ v)))))
(struct frame (app clo) #:transparent
    #:property prop:custom-write (lambda (v p w?)
                                 (fprintf p "(frame ~a ~a)" («app»-l (frame-app v)) («lam»-l (clo-lam (frame-clo v))))))

(define (eval0 e)

  (define (eval0‘ e)

    (define parent (make-parent e))

    (define (ast-declaration name e)
      (let up ((e e))
        (let ((p (parent e)))
          (match p
            (#f #f)
            ((«lam» _ x _)
             (let right ((x x))
               (if (null? x)
                   (up p)
                   (if (equal? name («id»-x (car x)))
                       (car x)
                       (right (cdr x))))))
            ((«let» _ x e0 e1)
             (if (eq? e0 e)
                 (up p)
                 (if (equal? name («id»-x x))
                     x
                     (up p))))
            ((«letrec» _ x _ _)
             (if (equal? name («id»-x x))
                 x
                 (up p)))
            (_ (up p))))))

    (define (global-lookup-b β)
      (eval (string->symbol (binding-decl β)) ns))

    (define (global-lookup decl)
      (eval (string->symbol decl) ns))

    (define (lookup-static decl e κ)
      ;(printf "static ~a ~a κ ~a\n" decl (ast->string e) (ast-seq->string κ))      
      (let ((pa (parent e)))
        (match pa
          ((«let» _ _ (== e) _)
           (lookup-static decl pa κ))
          ((«let» _ x _ _)
           (if (eq? decl x)
               (binding decl κ)
               (lookup-static decl pa κ)))
          ((«letrec» _ x _ _)
           (if (eq? decl x)
               (binding decl κ)
               (lookup-static decl pa κ)))
          ((«set!» _ _ _)
           (lookup-static decl pa κ))
          ((«app» _ _ _)
           (lookup-static decl pa κ))
          ((«lam» _ (list xs ...) _)
            (let param-loop ((xs xs))
             (if (null? xs)
                 (match-let (((frame _ (clo lam κ‘)) (car κ)))
                   (lookup-static decl lam κ‘))
                 (if (eq? decl (car xs))
                     (binding decl κ)
                     (param-loop (cdr xs))))))
          ((«begin» _ _)
           (lookup-static decl pa κ))
          ((«if» _ _ _ _)
           (lookup-static decl pa κ))
          ((«cons» _ _ _)
           (lookup-static decl pa κ))
          ((«car» _ _)
           (lookup-static decl pa κ))
          ((«cdr» _ _)
           (lookup-static decl pa κ))
          (#f (binding decl κ))
          (_ (error "cannot handle expression" pa)))))
 
    (define (lookup-dynamic β e κ)
     ; (printf "dyn    ~a ~a κ ~a pa ~a\n" β (ast->string e) (map ~a κ) (ast->string (parent e)))
      (let ((pa (parent e)))
        (match pa
          ((«let» _ _ (== e) _)
           ;(printf "let1\n")
           (lookup-dynamic β pa κ))
          ((«let» _ x e‘ _)
           (let ((β‘ (lookup-static x e κ)))
             ;(printf "let2 x ~a\n" (ast->string x))
             (if (equal? β β‘)
                 (eval0“ e‘ κ)
                 (lookup-value-down β e‘ κ))))
          ((«letrec» _ x (== e) _)
           (let ((β‘ (lookup-static x e κ)))
             (if (equal? β β‘)
                 (eval0“ e κ)
                 (lookup-dynamic β pa κ))))
          ((«letrec» _ x e‘ _)
           (let ((β‘ (lookup-static x e κ)))
             (if (equal? β β‘)
                 (eval0“ e‘ κ)
                 (lookup-value-down β e‘ κ))))
          ((«set!» _ _ (== e))
           ;(printf "set!1\n")
           (lookup-dynamic β pa κ))
          ((«set!» _ («id» _ x) e‘)
           ;(printf "set!2\n")
           (let ((β‘ (lookup-static (ast-declaration x e) e κ)))
             ;(printf "β  ~a\nβ‘ ~a\n" β‘ κ)
             (if (equal? β β‘)
                 (eval0“ e‘ κ)
                 (lookup-value-down β e‘ κ))))
          ((«app» _ (== e) _)
           (lookup-dynamic β pa κ))
          ((«app» _ e‘ (cons (== e) _))
           (lookup-value-down β e‘ κ))
          ((«app» _ e‘ es)
           (let arg-loop ((es es))
             (if (eq? (cadr es) e)
                 (lookup-value-down β (car es) κ)
                 (arg-loop (cdr es)))))
          ((«lam» _ (list xs ...) (== e))
           (let ((app (frame-app (car κ))))
             (let param-loop ((xs xs) (es («app»-aes app)))
               (if (null? xs)
                   (if (null? («app»-aes app))
                       (lookup-value-down β («app»-ae app) (cdr κ))
                       (lookup-value-down β (last («app»-aes app)) (cdr κ)))
                   (let ((β‘ (lookup-static (car xs) e κ)))
                     (if (equal? β β‘)
                         (eval0“ (car es) (cdr κ))
                         (param-loop (cdr xs) (cdr es))))))))
          ((«begin» _ (cons (== e) _))
           (lookup-dynamic β pa κ))
          ((«begin» _ es)
           (let exp-loop ((es es))
             (if (eq? (cadr es) e)
                 (lookup-value-down β (car es) κ)
                 (exp-loop (cdr es)))))
          ((«if» _ (== e) _ _)
           (lookup-dynamic β pa κ))
          ((«if» _ e0 (== e) _)
           (lookup-value-down β e0 κ))
          ((«if» _ e0 _ (== e))
           (lookup-value-down β e0 κ))
          ((«cons» _ (== e) _)
           (lookup-dynamic β pa κ))
          ((«cons» _ e0 _)
           (lookup-value-down β e0 κ))
          ((«car» _ _)
           (lookup-dynamic β pa κ))
          ((«cdr» _ _)
           (lookup-dynamic β pa κ))
          (#f (global-lookup-b β))
          (_ (error "cannot handle expression" pa)))))

    (define (lookup-value-down β e κ)
      ;(printf "down   ~a ~a κ ~a\n" β (ast->string e) (map ~a κ))
      (match e
        ((«app» _ e‘ es)
         (let ((d (eval0“ e‘ κ)))
           (match d
             ((clo («lam» _ _ e“) κ‘)
              (lookup-value-down β e“ (cons (frame e d) κ)))
             (_
              (let ((d‘ (lookup-dynamic β (last es) κ)))
                d‘)))))
        ((«if» _ e‘ e0 e1)
         (let ((d (eval0“ e‘ κ)))
           (lookup-value-down β (if d e0 e1) κ)))
        ((«let» _ _ _ e‘)
         (lookup-value-down β e‘ κ))
        ((«letrec» _ _ _ e‘)
         (lookup-value-down β e‘ κ))
        ((«set!» _ x _)
         (lookup-value-down β x κ))
        ((«car» _ e‘)
         (lookup-value-down β e‘ κ))
        ((«cdr» _ e‘)
         (lookup-value-down β e‘ κ))
        ((«cons» _ _ e1)
         (lookup-value-down β e1 κ))
        (_
         (let ((d (lookup-dynamic β e κ)))
           d))))

    (define (eval0“ e κ)
      ;(push-stack!)
      (let ((ddd
             (begin
      ;(printf "\n ~a eval   ~a κ ~a\n" STACK (ast->string e) (map ~a κ))
      (match e
        ((«lit» _ d) d)
        ((«lam» _ _ _) (clo e κ))
        ((«id» _ x)
         (let* ((β (lookup-static (or (ast-declaration x e) x) e κ))
                (d (lookup-dynamic β e κ)))
           ;(printf "=== ~a in ~a is ~a\n" x (parent e) d)
           d))
        ((«let» _ _ _ e1)
         (let ((d (eval0“ e1 κ)))
           d))
        ((«letrec» _ _ _ e1) (eval0“ e1 κ))
        ((«if» _ ae e0 e1)
         (let ((d (eval0“ ae κ)))
           (eval0“ (if d e0 e1) κ)))
        ((«begin» _ es)
         (eval0“ (last es) κ))
        ((«cons» _ e0 e1)
         (cons (eval0“ e0 κ) (eval0“ e1 κ)))
        ((«car» _ e)
         (let ((d (eval0“ e κ)))
           (car d)))
        ((«cdr» _ e)
         (let ((d (eval0“ e κ)))
           (cdr d)))
        ((«app» _ e‘ es)
         (let ((d (eval0“ e‘ κ)))
           (match d
             ((clo («lam» _ _ e“) κ‘)
              (eval0“ e“ (cons (frame e d) κ)))
             (_ (let ((args (map (lambda (e“) (eval0“ e“ κ)) es)))
                  ;(printf "PRIMAPP ~a ~a\n" d args)
                  (apply d args))))))
        ((«set!» _ x e‘)
         'undefined)
        (_ (error "cannot handle expression" e))))))
        ;(pop-stack! ddd)
        ddd))

    (eval0“ e '()))

  (eval0‘ (compile e)))


;;; TESTS

(define (test e expected)
  (let ((result
            (with-handlers ((exn:fail?
                             (lambda (exc) (if (eq? expected 'FAIL)
                                             'FAIL
                                             (begin
                                               (printf "unexpected failure for ~a:\n" e)
                                               (raise exc))))))
              (eval0 e))))
         (unless (equal? result expected)
           (error (format "wrong result for ~a:\n\texpected ~a\n\tgot      ~a" e expected result)))))

(test '123 123)
(test '(let ((x 10)) x) 10)
(test '(let ((x 10)) (let ((y 20)) y)) 20)
(test '(let ((x 10)) (let ((y 20)) x)) 10)
(test '(let ((x 10)) (let ((x 20)) x)) 20)
(test '(+ 1 1) 2)
(test '(let ((x (+ 1 1))) x) 2)
(test '(let ((f (lambda () (- 5 3)))) (f)) 2)
(test '(let ((f (lambda (x) (* x x)))) (f 4)) 16)
(test '(if #t 1 2) 1)
(test '(if #f 1 2) 2)
(test '(letrec ((f (lambda (x) (if x "done" (f #t))))) (f #f)) "done")
(test '(letrec ((f (lambda (x) (if (= x 2) x (f (+ x 1)))))) (f 0)) 2)
(test '(letrec ((fac (lambda (n) (if (= n 0) 1 (* n (fac (- n 1))))))) (fac 1)) 1)
(test '(letrec ((fac (lambda (n) (if (= n 0) 1 (let ((u (fac (- n 1)))) (* n u)))))) (fac 1)) 1)
(test '(begin 1 2 3) 3)
(test '(let ((x 123)) (let ((x #f)) "dummy") x) 123)
(test '(letrec ((fib (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 1)) 1)
(test '(letrec ((fib (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 3)) 2)
(test 'x 'FAIL)
(test '(let ((f (lambda () f))) (f)) 'FAIL)
(test '((lambda (x) (* x x)) 8) 64)
(test '(let ((g (lambda (v) v))) (let ((f (lambda (n) (let ((m (g 123))) (* m n))))) (f 2))) 246)
(test '(letrec ((count (lambda (n) (let ((t (= n 0))) (if t 123 (let ((u (- n 1))) (let ((v (count u))) v))))))) (count 8)) 123)
(test '(let ((f (lambda (x) x))) (let ((u (f 1))) (f 2))) 2)
(test '(let ((f (lambda (y) (let ((x y)) x)))) (let ((z (f "foo"))) (f 1))) 1)
(test '(letrec ((fac (lambda (n) (let ((t (= n 0))) (if t 1 (let ((u (- n 1))) (let ((v (fac u))) (* n v)))))))) (fac 1)) 1)
(test '(letrec ((fac (lambda (n) (let ((t (= n 0))) (if t 1 (let ((u (- n 1))) (let ((v (fac u))) (* n v)))))))) (fac 3)) 6)

; set!
(test '(let ((x 123)) (if #t (set! x 456) (set! x 789)) x) 456)
(test '(let ((x 123)) (if #f (set! x 456) (set! x 789)) x) 789)
(test '(let ((y 999)) (let ((x 123)) (if x (set! y 456) (set! y 789)) y)) 456)
(test '(let ((x 123)) (set! x 456) x) 456)
(test '(let ((x 123)) (set! x 456) (set! x 789) x) 789)
(test '(let ((x 123)) (if x (set! x 456) (set! x 789)) x) 456)
(test '(let ((x 123)) (set! x #f) (if x (set! x 456) (set! x 789)) x) 789)
(test '(let ((x #t)) (let ((f (lambda () (set! x #f)))) (f) x)) #f)
(test '(let ((x #t)) (let ((g (lambda () (set! x #f)))) (let ((f (lambda (h) (h)))) (f g) x))) #f)
(test '(let ((x 2)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (f 1))) 2)
(test '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((__ (f "foo"))) (f 1)))) "foo")
(test '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((_ (f 1))) (let ((__ (f "foo"))) (f 1))))) "foo")
(test '(let ((f (lambda (x) (let ((y (set! x "hoho"))) x)))) (f 1)) "hoho")
(test '(let ((f (lambda (x) (let ((y (set! x "hehe"))) x)))) (let ((u (f 1))) (f 2))) "hehe")
(test '(letrec ((x (begin (set! x 123) 456))) x) 456)
(test '(let ((x 123)) (let ((f (lambda (y) y))) (f (set! x 456)) x)) 456)
(test '(let ((x 123)) (let ((f (lambda (x) x))) (f (set! x 456)) x)) 456)
(test '(let ((x 123)) (let ((f (lambda (x y) x))) (f (set! x 456) 789) x)) 456)
(test '(let ((x 123)) (if (set! x 456) 789 0) x) 456)
(test '(let ((x 123)) (if (set! x 456) (set! x 789) (set! x 0)) x) 789)
(test '(let ((x 123)) (let ((y (set! x 456))) x)) 456)
(test '(let ((x 123)) (let ((y (set! x 456))) (set! x 789) x)) 789)
(test '(let ((x 123)) (let ((y (set! x 456))) (let ((z (set! x 789))) 0) x)) 789)
(test '(let ((x 123)) (let ((y (set! x 456))) (set! x 0) (let ((z (set! x 789))) 0) x)) 789)
(test '(let ((x 123)) (let ((y (set! x (set! x 456)))) x)) 'undefined)
(test '(let ((x 123)) (let ((y (set! x (begin (set! x 456) 789)))) x)) 789)

; cons-car-cdr
(test '(cons 1 2) (cons 1 2))
(test '(let ((o (cons 1 2))) (car o)) 1)
(test '(let ((o (cons 1 2))) (cdr o)) 2)
(test '(let ((o (cons 1 (cons 2 3)))) (car (cdr o))) 2)
(test '(let ((o (cons 1 (cons 2 3)))) (let ((v (cdr o))) (cdr v))) 3)
