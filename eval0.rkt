#lang racket

(random-seed 111) ; deterministic random
(define ns (make-base-namespace))

(struct «lit» (l d) #:transparent)
(struct «id» (l x) #:transparent)
(struct «quo» (l e) #:transparent)
(struct «lam» (l x e) #:transparent) 
(struct «app» (l ae aes) #:transparent)
(struct «let» (l x e0 e1) #:transparent)
(struct «letrec» (l x e0 e1) #:transparent)
(struct «if» (l ae e0 e1) #:transparent)
(struct «set!» (l x ae) #:transparent)
(struct «begin» (l es) #:transparent)
(struct «car» (l x) #:transparent)
(struct «cdr» (l x) #:transparent)
(struct «set-car!» (l x ae) #:transparent)
(struct «set-cdr!» (l x ae) #:transparent)
(struct «cons» (l ae1 ae2) #:transparent)
(struct «vector-ref» (l x ae) #:transparent)
(struct «vector-set!» (l x ae1 ae2) #:transparent)
(struct «make-vector» (l ae1 ae2) #:transparent)

(define (compile . es)
  (define l -1)
  (define (tag!)
    (set! l (add1 l))
    l)
  (define (compile-seq es)
    (if (null? (cdr es))
        (compile* (car es))
        («begin» (tag!) (map compile* es))))
  (define (compile* e)
    (match e
      ((? symbol? d) («id» (tag!) (symbol->string d)))
      ((? boolean? d) («lit» (tag!) d))
      ((? number? d) («lit» (tag!) d))
      ((? string? d)(«lit» (tag!) d))
      ((? char? d) («lit» (tag!) d))
      (`(quote ,e) («quo» (tag!) e))
      (`(lambda ,x ,es ...) («lam» (tag!) (map compile* x) (compile-seq es)))
      (`(if ,ae ,e1 ,e2) («if» (tag!) (compile* ae) (compile* e1) (compile* e2)))
      (`(let ((,x ,e0)) ,es ...) («let» (tag!) (compile* x) (compile* e0) (compile-seq es)))
      (`(letrec ((,x ,e0)) ,es ...) («letrec» (tag!) (compile* x) (compile* e0) (compile-seq es)))
      (`(set! ,x ,ae) («set!» (tag!) (compile* x) (compile* ae)))
      (`(begin ,es ...) (compile-seq es))
      (`(car ,x) («car» (tag!) (compile* x)))
      (`(cdr ,x) («cdr» (tag!) (compile* x)))
      (`(cons ,ae1 ,ae2) («cons» (tag!) (compile* ae1) (compile* ae2)))
      (`(set-car! ,x ,ae) («set-car!» (tag!) (compile* x) (compile* ae)))
      (`(set-cdr! ,x ,ae) («set-cdr!» (tag!) (compile* x) (compile* ae)))        
      (`(vector-ref ,x ,ae) («vector-ref» (tag!) (compile* x) (compile* ae)))
      (`(vector-set! ,x ,ae1 ,ae2) («vector-set!» (tag!) (compile* x) (compile* ae1) (compile* ae2)))
      (`(make-vector ,ae1 ,ae2) («make-vector» (tag!) (compile* ae1) (compile* ae2)))
      (`(,rator . ,rands) («app» (tag!) (compile* rator) (map compile* rands)))
      (_ (error "cannot handle expression" e))))
  (compile-seq es))
         
(define (ae? e)
  (match e
    ((«lit» _ _) #t)
    ((«id» _ _) #t)
    ((«lam» _ _ _) #t)
    ((«quo» _ e) (not (pair? e))) 
    (_ #f)))

(define (tail e)
  (match e
    ((«id» _ _) e)
    ((«lit» _ _) e)
    ((«lam» _ _ e) (tail e))
    ((«let» _ _ _ e) (tail e))
    ((«letrec» _ _ _ e) (tail e))
    ((«if» _ e _ _) (tail e))
    ((«set!» _ _ e) (tail e))
    ((«app» _ e es) (tail (last (cons e es))))
    ((«car» _ e) (tail e))
    ((«cdr» _ e) (tail e))
    ((«set-car!» _ _ e) (tail e))
    ((«set-cdr!» _ _ e) (tail e))
    ((«cons» _ _ e) (tail e))
    ((«make-vector» _ _ e) (tail e))
    ((«vector-ref» _ _ e) (tail e))
    ((«vector-set!» _ _ _ e) (tail e))
    ((«quo» _ e) (tail e))
    (_ (error "cannot handle expression" e))))

(define (children e)
  (match e
    ((«id» _ _) (set))
    ((«lit» _ _) (set))
    ((«lam» _ x e) (set-add (list->set x) e))
    ((«let» _ x e0 e1) (set x e0 e1))
    ((«letrec» _ x e0 e1) (set x e0 e1))
    ((«if» _ ae e1 e2) (set ae e1 e2))
    ((«car» _ x) (set x))
    ((«cdr» _ x) (set x))
    ((«set!» _ x ae) (set x ae))
    ((«set-car!» _ x ae) (set x ae))
    ((«set-cdr!» _ x ae) (set x ae))
    ((«cons» _ ae1 ae2) (set ae1 ae2))
    ((«make-vector» _ ae1 ae2) (set ae1 ae2))
    ((«vector-ref» _ x ae) (set x ae))
    ((«vector-set!» _ x ae1 ae2) (set x ae1 ae2))
    ((«quo» _ _) (set))
    ((«app» _ rator rands) (set-add (list->set rands) rator))
    ((«begin» _ es) (list->set es))
    (_ (error "cannot handle expression" e))))

(define (make-parent ast)
  (define (parent-map ast)
    (define (traverse-ast S W)
      (if (set-empty? W)
          S
          (let* ((e (set-first W))
                 (E* (children e))
                 (S* (for/fold ((S S)) ((e* E*))
                       (hash-set S e* e)))
                 (W* (set-union (set-rest W) E*)))
            (traverse-ast S* W*))))
    (traverse-ast (hash) (set ast)))
  
  (let ((P (parent-map ast)))
    (lambda (e)
      (hash-ref P e #f))))

  (define (pred-map ast)
    (define (traverse-ast S W)
      (if (set-empty? W)
          S
          (let* ((e (set-first W))
                 (S* (match e
                       ((«begin» _ es)
                        (let es-loop ((es es) (S S))
                          (if (null? (cdr es))
                              S
                              (es-loop (cdr es) (hash-set S (cadr es) (car es))))))
                       (_ S)))
                 (E* (children e))
                 (W* (set-union (set-rest W) E*)))
            (traverse-ast S* W*))))
    (traverse-ast (hash) (set ast)))


(define (make-pred ast)
  
  (let ((P (pred-map ast)))
    (lambda (e)
      (hash-ref P e #f))))

(struct clo (lam) #:transparent)

(define (eval0 e)
  
  (define (eval0* e)
    
    (define parent (make-parent e))
    (define pred (make-pred e))

    (define (global-lookup x)
      (eval (string->symbol x) ns))

    (define (lookup-var x e κ)
      ;(printf "lookup ~a ~a ~a\n" x e κ)
      (match e
        ((«set!» _ («id» _ (== x)) e0)
         (eval0** e0 κ))
        ((«if» _ ae e0 e1)
         (let ((d (eval0** ae κ)))
           (lookup-var x (if d e0 e1) κ)))
        ((«app» _ e0 _)
         (let ((d (eval0** e0 κ)))
           (match d
             ((clo («lam» _ _ e1))
              (lookup-var x e1 (cons e κ)))
             (_ (lookup-var-pred x e κ)))))
        ((«begin» _ es)
         (lookup-var x (last es) κ))
        (_ (lookup-var-pred x e κ))))

    (define (lookup-var-pred x e κ)
      ;(printf "pred ~a ~a ~a\n" x (pred e) κ)
      (let ((pr (pred e)))
        (if pr
            (lookup-var x pr κ)
            (lookup-var-parent x e κ))))
            
    (define (lookup-var-parent x e κ)
      ;(printf "parent ~a ~a ~a\n" x (parent e) κ)
      (let ((pa (parent e)))
        (match pa
          ((«let» _ _ (== e) _)
           (lookup-var-pred x pa κ))
          ((«let» _ («id» _ (== x)) e0 _)
           (eval0** e0 κ))
          ((«letrec» _ («id» _ (== x)) e0 _)
           (eval0** e0 κ))
          ((«lam» _ xs _)
           (let param-loop ((xs xs) (es («app»-aes (car κ))))
             (if (null? xs)
                 (lookup-var-pred x pa κ) ; or parent
                 (if (equal? («id»-x (car xs)) x)
                     (eval0** (car es) (cdr κ))
                     (param-loop (cdr xs) (cdr es))))))
          ((«set!» _ («id» _ (== x)) e0)
           (eval0** e0 κ))
;          ((«app» _ e0 _)
;           (let ((d (eval0** e0 κ)))
;             (match d
;               ((clo («lam» _ _ e1))
;                (lookup-var x e1 (cons pa κ)))
;               (_ (lookup-var-pred x pa κ)))))
          (#f (global-lookup x))
          (_ (lookup-var-pred x pa κ)))))
    
    (define (eval0** e κ)
      (match e
        ((«lit» _ d) d)
        ((«lam» _ _ _) (clo e))
        ((«id» _ x) (lookup-var-pred x e κ))
        ((«let» _ _ _ e1) (eval0** e1 κ))
        ((«letrec» _ _ _ e1) (eval0** e1 κ))
        ((«if» _ ae e0 e1)
         (let ((d (eval0** ae κ)))
           (eval0** (if d e0 e1) κ)))
        ((«begin» _ es)
         (eval0** (last es) κ))
        ((«app» _ ae aes)
         (let ((d (eval0** ae κ)))
           (match d
             ((clo («lam» _ _ e*))
              (eval0** e* (cons e κ)))
             (_ (apply d (map (lambda (ae) (eval0** ae κ)) aes))))))
        (_ (error "cannot handle expression" e))))

    (eval0** e '()))
  
  (eval0* (compile e)))

(define tests '())
(define (add-test! e expected)
  (set! tests (cons (cons e expected) tests)))
(add-test! '123 123)
(add-test! '(let ((x 10)) x) 10)
(add-test! '(let ((x 10)) (let ((y 20)) y)) 20)
(add-test! '(let ((x 10)) (let ((y 20)) x)) 10)
(add-test! '(let ((x 10)) (let ((x 20)) x)) 20)
(add-test! '(+ 1 1) 2)
(add-test! '(let ((x (+ 1 1))) x) 2)
(add-test! '(let ((f (lambda () (- 5 3)))) (f)) 2)
(add-test! '(let ((f (lambda (x) (* x x)))) (f 4)) 16)
(add-test! '(if #t 1 2) 1)
(add-test! '(if #f 1 2) 2)
(add-test! '(letrec ((f (lambda (x) (if x "done" (f #t))))) (f #f)) "done")
(add-test! '(letrec ((f (lambda (x) (if (= x 2) x (f (+ x 1)))))) (f 0)) 2)
(add-test! '(begin 1 2 3) 3)
(add-test! '(let ((x 123)) (set! x 456) x) 456)
(add-test! '(let ((x 123)) (set! x 456) (set! x 789) x) 789)
(add-test! '(let ((x 123)) (if x (set! x 456) (set! x 789)) x) 456)
(add-test! '(let ((x 123)) (set! x #f) (if x (set! x 456) (set! x 789)) x) 789)
(add-test! '(let ((x 123)) (let ((x #f)) "dummy") x) 123)
(add-test! '(letrec ((fib (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 1)) 1)
(add-test! '(letrec ((fib (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 3)) 2)
(add-test! 'x 'FAIL)
(add-test! '(let ((f (lambda () f))) (f)) 'FAIL)
(add-test! '(let ((x #t)) (let ((f (lambda () (set! x #f)))) (f) x)) #f)
(add-test! '(let ((x #t)) (let ((g (lambda () (set! x #f)))) (let ((f (lambda (h) (h)))) (f g) x))) #f)
(for ((test tests))
     (let ((result
            (with-handlers ((exn:fail?
                             (lambda (e) (unless (eq? (cdr test) 'FAIL)
                                           (error "unexpected failure for" test))
                               'FAIL)))
              (eval0 (car test)))))
         (unless (equal? result (cdr test))
           (error "wrong result for" test))))