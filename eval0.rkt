#lang racket

(random-seed 111) ; deterministic random
(define ns (make-base-namespace))

(struct «lit» (l d) #:transparent)
(struct «id» (l x) #:transparent)
(struct «quo» (l e) #:transparent)
(struct «lam» (l x e) #:transparent) 
(struct «app» (l ae aes) #:transparent)
(struct «let» (l x e0 e1) #:transparent)
(struct «letrec» (l x e0 e1) #:transparent)
(struct «if» (l ae e0 e1) #:transparent)
(struct «set!» (l x ae) #:transparent)
(struct «begin» (l es) #:transparent)
(struct «car» (l x) #:transparent)
(struct «cdr» (l x) #:transparent)
(struct «set-car!» (l x ae) #:transparent)
(struct «set-cdr!» (l x ae) #:transparent)
(struct «cons» (l ae1 ae2) #:transparent)
(struct «vector-ref» (l x ae) #:transparent)
(struct «vector-set!» (l x ae1 ae2) #:transparent)
(struct «make-vector» (l ae1 ae2) #:transparent)

(define (compile . es)
  (define l -1)
  (define (tag!)
    (set! l (add1 l))
    l)
  (define (compile-seq es)
    (if (null? (cdr es))
        (compile* (car es))
        («begin» (tag!) (map compile* es))))
  (define (compile* e)
    (match e
      ((? symbol? d) («id» (tag!) (symbol->string d)))
      ((? boolean? d) («lit» (tag!) d))
      ((? number? d) («lit» (tag!) d))
      ((? string? d)(«lit» (tag!) d))
      ((? char? d) («lit» (tag!) d))
      (`(quote ,e) («quo» (tag!) e))
      (`(lambda ,x ,es ...) («lam» (tag!) (map compile* x) (compile-seq es)))
      (`(if ,ae ,e1 ,e2) («if» (tag!) (compile* ae) (compile* e1) (compile* e2)))
      (`(let ((,x ,e0)) ,es ...) («let» (tag!) (compile* x) (compile* e0) (compile-seq es)))
      (`(letrec ((,x ,e0)) ,es ...) («letrec» (tag!) (compile* x) (compile* e0) (compile-seq es)))
      (`(set! ,x ,ae) («set!» (tag!) (compile* x) (compile* ae)))
      (`(begin ,es ...) (compile-seq es))
      (`(car ,x) («car» (tag!) (compile* x)))
      (`(cdr ,x) («cdr» (tag!) (compile* x)))
      (`(cons ,ae1 ,ae2) («cons» (tag!) (compile* ae1) (compile* ae2)))
      (`(set-car! ,x ,ae) («set-car!» (tag!) (compile* x) (compile* ae)))
      (`(set-cdr! ,x ,ae) («set-cdr!» (tag!) (compile* x) (compile* ae)))        
      (`(vector-ref ,x ,ae) («vector-ref» (tag!) (compile* x) (compile* ae)))
      (`(vector-set! ,x ,ae1 ,ae2) («vector-set!» (tag!) (compile* x) (compile* ae1) (compile* ae2)))
      (`(make-vector ,ae1 ,ae2) («make-vector» (tag!) (compile* ae1) (compile* ae2)))
      (`(,rator . ,rands) («app» (tag!) (compile* rator) (map compile* rands)))
      (_ (error "cannot handle expression" e))))
  (compile-seq es))
         
(define (ae? e)
  (match e
    ((«lit» _ _) #t)
    ((«id» _ _) #t)
    ((«lam» _ _ _) #t)
    ((«quo» _ e) (not (pair? e))) 
    (_ #f)))

(define (children e)
  (match e
    ((«id» _ _) (set))
    ((«lit» _ _) (set))
    ((«lam» _ x e) (set-add (list->set x) e))
    ((«let» _ x e0 e1) (set x e0 e1))
    ((«letrec» _ x e0 e1) (set x e0 e1))
    ((«if» _ ae e1 e2) (set ae e1 e2))
    ((«car» _ x) (set x))
    ((«cdr» _ x) (set x))
    ((«set!» _ x ae) (set x ae))
    ((«set-car!» _ x ae) (set x ae))
    ((«set-cdr!» _ x ae) (set x ae))
    ((«cons» _ ae1 ae2) (set ae1 ae2))
    ((«make-vector» _ ae1 ae2) (set ae1 ae2))
    ((«vector-ref» _ x ae) (set x ae))
    ((«vector-set!» _ x ae1 ae2) (set x ae1 ae2))
    ((«quo» _ _) (set))
    ((«app» _ rator rands) (set-add (list->set rands) rator))
    ((«begin» _ es) (list->set es))
    (_ (error "cannot handle expression" e))))

(define (ast-seq->string es)
  (if (null? es)
      ""
      (if (null? (cdr es))
          (ast->string (car es))
          (string-append (ast->string (car es)) " " (ast-seq->string (cdr es))))))

(define (ast->string e)
  (match e
    ((«id» _ x) x)
    ((«lit» _ d) (~a d))
    ((«lam» _ x e) (format "(lambda (~a) ~a)" (ast-seq->string x) (ast->string e)))
    ((«let» _ x e0 e1) (format "(let ((~a ~a)) ~a)" (ast->string x) (ast->string e0) (ast->string e1)))
    ((«letrec» _ x e0 e1) (format "(letrec ((~a ~a)) ~a)" (ast->string x) (ast->string e0) (ast->string e1)))
    ((«if» _ e0 e1 e2) (format "(if ~a ~a ~a)" (ast->string e0) (ast->string e1) (ast->string e2)))
    ((«app» _ e es) (format "(~a ~a)" (ast->string e) (ast-seq->string es)))
    ((«begin» _ es) (format "(begin ~a)" (ast-seq->string es)))
    ((«set!» _ x e) (format "(set! ~a ~a)" (ast->string x) (ast->string e)))
    (_ (~a e))))

(define (make-parent ast)
  (define (parent-map ast)
    (define (traverse-ast S W)
      (if (set-empty? W)
          S
          (let* ((e (set-first W))
                 (E* (children e))
                 (S* (for/fold ((S S)) ((e* E*))
                       (hash-set S e* e)))
                 (W* (set-union (set-rest W) E*)))
            (traverse-ast S* W*))))
    (traverse-ast (hash) (set ast)))
  
  (let ((P (parent-map ast)))
    (lambda (e)
      (hash-ref P e #f))))

  (define (pred-map ast)
    (define (traverse-ast S W)
      (if (set-empty? W)
          S
          (let* ((e (set-first W))
                 (S* (match e
                       ((«begin» _ es)
                        (let es-loop ((es es) (S S))
                          (if (null? (cdr es))
                              S
                              (es-loop (cdr es) (hash-set S (cadr es) (car es))))))
                       ((«let» _ _ e0 e1)
                        ;(printf "~a->~a\n" e1 e0)
                        (hash-set S e1 e0))
                       ((«letrec» _ _ e0 e1)
                        ;(printf "~a->~a\n" e1 e0)
                        (hash-set S e1 e0))
                       (_ S)))
                 (E* (children e))
                 (W* (set-union (set-rest W) E*)))
            (traverse-ast S* W*))))
    (traverse-ast (hash) (set ast)))


(define (make-pred ast)
  
  (let ((P (pred-map ast)))
    (printf "~a\n" P)
    (lambda (e)
      (hash-ref P e #f))))

(struct clo (lam) #:transparent)

(define (eval0 e)
  
  (define (eval0‘ e)
    
    (define parent (make-parent e))

    (define (ast-declaration name e)
      (let up ((e e))
        (let ((p (parent e)))
          (match p
            (#f #f)
            ((«lam» _ x _)
             (let right ((x x))
               (if (null? x)
                   (up p)
                   (if (equal? name («id»-x (car x)))
                       (car x)
                       (right (cdr x))))))
            ((«let» _ x e0 e1)
             (if (eq? e0 e)
                 (up p)
                 (if (equal? name («id»-x x))
                     x
                     (up p))))
            ((«letrec» _ x _ _)
             (if (equal? name («id»-x x))
                 x
                 (up p)))
            (_ (up p))))))
    
    (define (global-lookup x)
      (eval (string->symbol x) ns))

    (define (lookup-var-down decl e κ)
      ;(printf "down   ~a ~a κ ~a\n" decl (ast->string e) (ast-seq->string κ))
      (match e
        ((«app» _ e‘ es)
         (let ((d (eval0“ e‘ κ)))
           (match d
             ((clo («lam» _ _ e“))
              (lookup-var-down decl e“ (cons e κ)))
             (_ (lookup-var decl (last es) κ)))))
        ((«if» _ e‘ e0 e1)
         (let ((d (eval0“ e‘ κ)))
           (lookup-var-down decl (if d e0 e1) κ)))
        ((«let» _ x _ _)
         (lookup-var decl x κ))
        ((«letrec» _ x _ _)
         (lookup-var decl x κ))
        ((«set!» _ x _)
         (lookup-var decl x κ))
        (_ (lookup-var decl e κ))))
            
    (define (lookup-var decl e κ)
      (printf "lookup ~a ~a ==> ~a κ ~a\n" decl (ast->string e) (ast->string (parent e)) (ast-seq->string κ))
      (let ((pa (parent e)))
        (match pa
          ((«let» _ _ (== e) _)
           (lookup-var decl pa κ))
          ((«let» _ x e‘ _)
           (if (eq? decl x)
               (eval0“ e‘ κ)
               (lookup-var-down decl e‘ κ)))
          ((«letrec» _ x (== e) _)
           (if (eq? decl x)
               (eval0“ e κ)
               (lookup-var decl pa κ)))
          ((«letrec» _ x e‘ _)
           (if (eq? decl x)
               (eval0“ e‘ κ)
               (lookup-var-down decl e‘ κ)))
          ((«set!» _ _ (== e))
           (lookup-var decl pa κ))
          ((«set!» _ («id» _ x) e‘)
           (if (eq? decl (ast-declaration x e))
               (eval0“ e‘ κ)
               (lookup-var-down decl e‘ κ)))
          ((«app» _ (== e) _)
           (lookup-var decl pa κ))
          ((«app» _ _ es)
           (if (eq? e (car es))
               (lookup-var decl pa κ)
               (let arg-loop ((es es))
                 (if (null? (cdr es))
                     (lookup-var-down decl (car es) κ)
                     (if (eq? (cadr es) e)
                         (lookup-var-down decl (car es) κ)
                         (arg-loop (cdr es)))))))
          ((«lam» _ (list xs ...) (== e))
            (let param-loop ((xs xs) (es («app»-aes (car κ))))
             (if (null? xs)
                 (if (null? es)
                     (lookup-var decl («app»-ae (car κ)) (cdr κ))
                     (lookup-var decl (last es) (cdr κ)))
                 (if (eq? decl (car xs))
                     (eval0“ (car es) (cdr κ))
                     (param-loop (cdr xs) (cdr es))))))
          ((«begin» _ (cons (== e) _))
           (lookup-var decl pa κ))
          ((«begin» _ es)
           (let exp-loop ((es es))
             (if (null? (cdr es))
                 (lookup-var-down decl (car es) κ)
                 (if (eq? (cadr es) e)
                     (lookup-var-down decl (car es) κ)
                     (exp-loop (cdr es))))))
          ((«if» _ (== e) _ _)
           (lookup-var decl pa κ))
          ((«if» _ e0 (== e) _)
           (lookup-var-down decl e0 κ))
          ((«if» _ e0 _ (== e))
           (lookup-var-down decl e0 κ))
          (#f (global-lookup decl))
          (_ (error "cannot handle expression" pa)))))
    
    (define (eval0“ e κ)
      (printf "\neval   ~a κ ~a\n" (ast->string e) (ast-seq->string κ))
      (match e
        ((«lit» _ d) d)
        ((«lam» _ _ _) (clo e))
        ((«id» _ x) (lookup-var (or (ast-declaration x e) x) e κ))
        ((«let» _ _ _ e1) (eval0“ e1 κ))
        ((«letrec» _ _ _ e1) (eval0“ e1 κ))
        ((«if» _ ae e0 e1)
         (let ((d (eval0“ ae κ)))
           (eval0“ (if d e0 e1) κ)))
        ((«begin» _ es)
         (eval0“ (last es) κ))
        ((«app» _ e‘ es)
         (let ((d (eval0“ e‘ κ)))
           (match d
             ((clo («lam» _ _ e“))
              (eval0“ e“ (cons e κ)))
             (_ (apply d (map (lambda (e“) (eval0“ e“ κ)) es))))))
        (_ (error "cannot handle expression" e))))

    (eval0“ e '()))
  
  (eval0‘ (compile e)))

(define tests '())
(define (add-test! e expected)
  (set! tests (cons (cons e expected) tests)))
(add-test! '123 123)
(add-test! '(let ((x 10)) x) 10)
(add-test! '(let ((x 10)) (let ((y 20)) y)) 20)
(add-test! '(let ((x 10)) (let ((y 20)) x)) 10)
(add-test! '(let ((x 10)) (let ((x 20)) x)) 20)
(add-test! '(+ 1 1) 2)
(add-test! '(let ((x (+ 1 1))) x) 2)
(add-test! '(let ((f (lambda () (- 5 3)))) (f)) 2)
(add-test! '(let ((f (lambda (x) (* x x)))) (f 4)) 16)
(add-test! '(if #t 1 2) 1)
(add-test! '(if #f 1 2) 2)
(add-test! '(let ((x 123)) (if #t (set! x 456) (set! x 789)) x) 456)
(add-test! '(let ((x 123)) (if #f (set! x 456) (set! x 789)) x) 789)
(add-test! '(let ((y 999)) (let ((x 123)) (if x (set! y 456) (set! y 789)) y)) 456)
(add-test! '(letrec ((f (lambda (x) (if x "done" (f #t))))) (f #f)) "done")
(add-test! '(letrec ((f (lambda (x) (if (= x 2) x (f (+ x 1)))))) (f 0)) 2)
(add-test! '(begin 1 2 3) 3)
(add-test! '(let ((x 123)) (set! x 456) x) 456)
(add-test! '(let ((x 123)) (set! x 456) (set! x 789) x) 789)
(add-test! '(let ((x 123)) (if x (set! x 456) (set! x 789)) x) 456)
(add-test! '(let ((x 123)) (set! x #f) (if x (set! x 456) (set! x 789)) x) 789)
(add-test! '(let ((x 123)) (let ((x #f)) "dummy") x) 123)
(add-test! '(letrec ((fib (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 1)) 1)
;(add-test! '(letrec ((fib (lambda (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))))) (fib 3)) 2)
(add-test! 'x 'FAIL)
(add-test! '(let ((f (lambda () f))) (f)) 'FAIL)
(add-test! '(let ((x #t)) (let ((f (lambda () (set! x #f)))) (f) x)) #f)
(add-test! '(let ((x #t)) (let ((g (lambda () (set! x #f)))) (let ((f (lambda (h) (h)))) (f g) x))) #f)
(add-test! '((lambda (x) (* x x)) 8) 64)
(add-test! '(letrec ((count (lambda (n) (let ((t (= n 0))) (if t 123 (let ((u (- n 1))) (let ((v (count u))) v))))))) (count 8)) 123)
(add-test! '(let ((f (lambda (x) x))) (let ((u (f 1))) (f 2))) 2)
(add-test! '(let ((f (lambda (y) (let ((x y)) x)))) (let ((z (f "foo"))) (f 1))) 1)
;(add-test! '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((__ (f "foo"))) (f 1)))) "foo")
;(add-test! '(let ((x 1)) (let ((f (lambda (y) (let ((oldx x)) (let ((_ (set! x y))) oldx))))) (let ((_ (f 1))) (let ((__ (f "foo"))) (f 1))))) "foo")
(add-test! '(let ((f (lambda (x) (let ((y (set! x "hoho"))) x)))) (f 1)) "hoho")
(add-test! '(let ((f (lambda (x) (let ((y (set! x "hehe"))) x)))) (let ((u (f 1))) (f 2))) "hehe")
(add-test! '(letrec ((fac (lambda (n) (let ((t (= n 0))) (if t 1 (let ((u (- n 1))) (let ((v (fac u))) (* n v)))))))) (fac 1)) 1)
;(add-test! '(letrec ((fac (lambda (n) (let ((t (= n 0))) (if t 1 (let ((u (- n 1))) (let ((v (fac u))) (* n v)))))))) (fac 8)) 40320)

(for ((test tests))
     (let ((result
            (with-handlers ((exn:fail?
                             (lambda (e) (if (eq? (cdr test) 'FAIL)
                                             'FAIL
                                             (begin
                                               (printf "unexpected failure for ~a:\n" test)
                                               (raise e))))))
              (eval0 (car test)))))
         (unless (equal? result (cdr test))
           (error (format "wrong result for ~a:\n\texpected ~a\n\tgot      ~a" (car test) (cdr test) result)))))